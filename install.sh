#!/bin/bash
# Installs the required dependencies and symlinks the config files
# VERSION: 0.1.0

# ---------------- #
# GLOBAL VARIABLES #
# ---------------- #

# Process ID of the spinner when it's running
# (the little loading spinner icon that's animated)
_SPIN_PID=""

# ---------------- #
# GLOBAL FUNCTIONS #
# ---------------- #

_spinner() {

  # Duration between each frame of the animation
  local framerate=$1

  # Characters to animate for the spinner
  local spinner=$2

  # Number of animation frames to use
  local total_frames=$((${#spinner} - 1))

  # Animate the spinner indefinitely (until killed)
  while :; do

    # Loop through each character in the spinner
    for i in $(seq 0 $total_frames); do

      # Print the spinner frame
      echo -n " [${spinner:$i:1}]"

      # Clear previous for next animation frame
      echo -ne "\b\b\b\b"

      # Wait $framerate for the next frame
      sleep "$framerate"

    done

  done

}

# Function to show a spinner while something is loading
# shellcheck disable=SC2120
show_spinner() {

  # Duration between each frame of the animation
  local framerate=${1:-0.2}

  # Characters to animate for the spinner
  local spinner=${2:-"/|\\-/|\\-"}

  # Start showing the spinner animation
  _spinner "$framerate" "$spinner" &

  # Update the $_SPIN_PID global variable
  _SPIN_PID=$!

  # Kill the spinner on any signal, including our own exit
  trap 'kill -9 $_SPIN_PID' $(seq 0 15) >/dev/null 2>&1

}

# Function to kill the spinner on demand
stop_spinner() {

  # Check if the _SPIN_PID process is still running or not
  if ps -p "$_SPIN_PID" >/dev/null; then

    # Kill the spinner PID
    kill $_SPIN_PID

  fi

}

# shellcheck disable=SC2120
_try-again() {

  # Whether or not to try again
  # Default: y / yes
  local answer="y"

  # Question to ask in the prompt
  local question=${1:-"Would you like to try again?"}

  read -pr "$question [y/n]: " response

  # Anser is the response or the default
  response=${response:-"$answer"}

  # Convert the answer to lowercase
  response=$(echo "$response" | tr '[:upper:]' '[:lower:]')

  # Check if it's 'y' or 'yes'
  if [ "$response" == "y" ] || [ "$response" == "yes" ]; then

    # We ARE going to try again
    return 0

  else

    # We ARE NOT going to try again
    return 1

  fi

}

# ---------------- #
# SCRIPT VARIABLES #
# ---------------- #

# General required packages for the config files
# These dependencies are required on all distributions/systems
req_deps_all="exa curl git gh nmap pup nano"

# Required packages for Arch Linux installations
req_deps_arch="yay dhcpcd wpa_supplicant sudo ssh acpi"

# Required packages for Ubuntu Linux installations
req_deps_ubuntu=""

# Required packages for Kali Linux installations
req_deps_kali=""

# Required packages for macOS installations
req_deps_macos="brew"

# Name of the OS we're running on (e.g. macos, arch, ubuntu, kali, etc.)
os_name=""

# List of packages that need to get installed
# This list is generated by the install script
declare -a pkgs_to_install=()

# ---------------- #
# SCRIPT FUNCTIONS #
# ---------------- #

# Function to check if the a specified bin is installed
# @argument: [REQUIRED] Command to test (e.g. curl)
is-installed() {

  # Whether or not to print verbosely
  verbose_mode="disabled"

  if [ "$1" == "-v" ]; then

    # We should run verbosely
    verbose_mode="enabled"

    # Shift arguments so $2 is now $1
    shift

  fi

  print-it() {

    # Message to print
    msg="$1"

    # Check if we're running verbosely or not
    if [ "$verbose_mode" == "enabled" ]; then

      #  We ARE printing verbosely
      echo -ne "$msg"
      return 0

    fi

  }


  if [ "$#" -eq 0 ]; then


    echo >&2 "${FUNCNAME[0]} \033[0;31m[ERROR]\033[0m: Command is required but was not found in arguments"
    return 1

  fi

  print-it "Checking for presence of '$1' command... "

  # Allow time to read the message
  sleep 0.5

  if ! command -v "$1" > /dev/null; then

    print-it "\033[0;31m[ERROR]\033[0m: '$1' command not found\n"

    return 1

  fi

  print-it "\033[0;32m[DONE]\033[0m: '$1' command installed\n"

  return 0

}

# Function to check which OS we're running on
# Prints results
which-os() {

  # Get the type of kernel we're on (Linux / macOS)
  # Also convert it to lowercase
  local kernel_type=""
        kernel_type=$(uname | tr '[:upper:]' '[:lower:]')

  # Check if we're on Linux or macOS
  if [ "$kernel_type" == "darwin" ]; then

    # We're running on macOS
    os_name "macos"
    return 0

  fi

  # Otherwise, get the Linux distro we're running on (convert it to lowercase)
  local linux_distro=""
        linux_distro=$(grep -E '^NAME' /etc/os-release | grep -Eio '"[^"]+\"$' | sed 's/"//g' | tr '[:upper:]' '[:lower:]')

  case "$linux_distro" in

    "arch" | "arch linux")
      os_name="arch"
      ;;
    "ubuntu" | "ubuntu linux")
      os_name="ubuntu"
      ;;
    "kali" | "kali linux")
      os_name="kali"
      ;;
    *)
      os_name="unknown"
      return 1
      ;;
  esac

  echo "$os_name"
  return 0

}

# Check which dependencies need to be installed for all machines
# @argument: {STRING} --> OS to check depedencies for (e.g. macos, arch, kali, ubuntu, etc.)
# shellcheck disable=SC2120
check-deps() {

  # Which OS to check dependencies for
  # @default: pkgs that are required on ALL systems
  os_to_check=${1:-"all"}

  # Dependencies to check for
  deps_to_check=""

  case "$os_to_check" in

    "all")
      deps_to_check=$req_deps_all
      ;;
    
    "macos")
      deps_to_check=$req_deps_macos
      ;;
    
    "kali")
      deps_to_check=$req_deps_kali
      ;;
    
    "ubuntu")
      deps_to_check=$req_deps_ubuntu
      ;;
    
    "arch")
      deps_to_check=$req_deps_arch
      ;;
    
    *)
      # Not recognized OS to check
      echo >&2 "${FUNCNAME[0]} \033[0;31m[ERROR]\033[0m: Unrecognized OS to check in arguments"
      return 1

  esac

  for dep in $deps_to_check; do

    # Check if the command is valid in this system
    # If the command is not valid, add it to the list of 
    # dependencies to install later
    is-installed "$dep" || pkgs_to_install+=("$dep")

  done

}

# ------------------ #
# CHECK DEPENDENCIES #
# ------------------ #

# Check all required dependencies
# Check required dependencies for this specific OS we're running on

# Check which method we're going to use to install the packages
# pacman, yay, apt, brew, npm, curl, etc.

# -------------------- #
# INSTALL DEPENDENCIES #
# -------------------- #

# Check if $pkgs_to_install is empty or not
# --> If it isn't empty, proceed to install the dependencies

# Install missing dependencies

# --> If it is empty, skip and proceed to next step

# -------------------- #
# SYMLINK CONFIG FILES #
# -------------------- #

# Sym link files in /src/symlinked to ~

# ------------------- #
# CHANGE SHELL TO ZSH #
# ------------------- #

# Change shell to zsh
# NOTE: This may require that we exit the shell and start a new one. This would be the final step for the user to perform

# Change source to ~/.zshrc

# ------------------------------ #
# GRACEFULLY EXIT INSTALL SCRIPT #
# ------------------------------ #